	mutation {
    makeClozeAttempt(userId: 234, sentenceId: 34, isCorrect: true, nextSentenceId: 184)


  }


MATCH (i:TimeInterval)<-[:AT_INTERVAL]-(s:Sentence)-[:TEACHES]->(w:Word),(u:User{user_name: 'admin'})
                  OPTIONAL MATCH (s)-[:CONTAINS]->(wd:Word)
                  //get word dependencies
                  OPTIONAL MATCH (wd)<-[:TEACHES]-(ds:Sentence)-[:AT_INTERVAL]->(di:TimeInterval),(u)-[:LEARNING]->(ds)
                  //find the interval the the sentence dependencies that the user is learning
                  WITH u,w,i,s,collect({word_text: wd.text, current_interval:COALESCE(di.interval_order,0)}) AS word_dependencies
                  //aggregate progress for every dependent word's farthest interval
                  WHERE 
                  NOT EXISTS((u)-[:LEARNED]->(w)) AND 
                  ((EXISTS((u)-[:LEARNING]->(s)) OR (NOT EXISTS((u)-[:LEARNING]->(:Sentence)-[:TEACHES]->(w:Word)) AND i.interval_order = 1)))
                  //Check that user is either learning at that interval or it's the first interval
                  AND ALL(wd IN word_dependencies WHERE wd.word_text IS NULL OR wd.current_interval >= i.interval_order)
                  //Check that every dependent word is at the same interval
                  //HERE DO A MATCH TO FIND THOSE THAT TEACH THE WORD WITH THE MOST UPSTREAM DEPENDENCIES
MATCH (u)
CALL apoc.path.expandConfig(u, {
    relationshipFilter: "LEARNING|TEACHES, CONTAINS",
    terminatorNodes: [s],
    minLevel: 1,
    maxLevel: 4
})
YIELD path
RETURN  last(nodes(path)), length(path) AS hops
ORDER BY hops DESC


                  CALL apoc.do.when(isCorrect,
                    "CALL apoc.refactor.to(r, i2) YIELD input RETURN 1") YIELD value
"CREATE (u)-[:LEARNING]->(s)",{s:s, u:u}

for interval 2 add words 有点儿，有点，一点，没，天，它们

MATCH(w:Word)
WHERE SIZE(w.text) > 1
WITH w as current_word, w.word_id AS word_id, split(w.text,'') AS x, split(w.alt_text,'') AS x2
WITH current_word, word_id, x,x2, RANGE(0, SIZE(x) - 1) AS indexes
FOREACH(index in indexes | 
	MERGE(nw:Word {text: x[index]})
    ON CREATE set 
    nw.word_id = '0',
    nw.is_test = TRUE,
    nw.alt_text=x2[index]
    ON MATCH set 
    nw.word_id = nw.word_id,
    nw.tones = nw.tones,
    nw.pinyin = nw.pinyin,
    nw.english = nw.english,
    nw.alt_text=x2[index]
)

MATCH(s:Sentence),(w:Word {text: '他们'})
WHERE EXISTS((s)-[:CONTAINS]->(w))
SET
s.display_text = REPLACE(s.display_text,'他们','他'),
s.alt_display_text = REPLACE(s.alt_display_text,'他們','他'),
s.raw_text = REPLACE(s.raw_text,'他们','他'),
s.alt_raw_text = REPLACE(s.alt_raw_text,'他們','他')
RETURN s

MATCH(s:Sentence),(w1:Word {text: '他们'}),(w2:Word {text: '他'})
WHERE EXISTS((s)-[:CONTAINS]->(w1))
CREATE (s)-[:CONTAINS]->(w2)
RETURN s,w1,w2


CALL apoc.export.cypher.all("all-plain.cypher", {
    format: "plain",
    useOptimizations: {type: "UNWIND_BATCH", unwindBatchSize: 20}
})
YIELD file, batches, source, format, nodes, relationships, properties, time, rows, batchSize
RETURN file, batches, source, format, nodes, relationships, properties, time, rows, batchSize;



MATCH(s:Sentence)-[rel:CONTAINS]->(w1:Word {text: '他们'})
DELETE rel

cat import/07-26-2020-copy | ./bin/cypher-shell -a bolt://localhost:7687 -u neo4j -p password --format verbose

Idea #1
Can create a sentence at an interval if a sentence for the same word at the previous interval exists

Can use any word for a which a first interval sentence exists (or a base word)


when querying the words:

must wait for source word to have answered the first interval correctly in order to show the destination sentence 


at the second interval and higher must use at least one additional word from the podcast that is not a base word


(when searching words order by have the fewest sentence in which they are found)

can't use a 2+ interval of a word if that a sentence containing that word at the previous interval as not been used



must use every word atleast once as and additional word; authoring app should have a list of word that have not been used yet.


Time intervals and episode intervals

if the episode interval is reached that word must be reviewed after all the new words have been learned


In author app


1. make user choose next word to teach (drop down order by lowest interval ascending then make add word button appear

2. make user choose words to include (with backspace) make sure to only include words that they have the right to use (order by least recently used (in episodes)) (also include filter for words taught in this episode)

3. if the user is at second interval or higher show message that they must include a word in the episode that has not yet been contained in the interval(if there are some that remain), make message dissapear when they have done it

4. Before being able to write second interval sentence for a word, it must be contained in a sentence teaching another word at .

4. Have a store of sentences actually used in podcast, when all the necessary words have been introduced suggest the sentence to the user.



Rules Clearly:

Start with base words of hsk1-hsk3


Interval 1:

Each sentence:
Can Teach: any word
Must Teach: 1 word
Can Contain: only word being taught (besides base words)

Sum of sentences:
Must teach: every word


Interval 2+:

Each sentence:

Can Teach: any word
Can Contain: word that has been taught as previous interval
Must Contain: word besides word being taught that has not yet been contained at this interval


Sum of sentences:
Must teach: every word
Must constain: every word


ALSO

interval 1: 1-4

interval 2: 4-5

interval 3: 5-6

interval 4: 6-7

interval 5: 7-8

interval 6: 8-9

interval 7: 9-10



sentence 1: 1-5

sentence 2: 6-8

sentence 3: 9-10







Dependent words that are not learned:
in HSK1:
他们，她们，吃饭/饭

HSK3:
以后，后面

Seperable words:
in HSK1 



add 你们，他们 to hsk1
etc

for place holders we can just use 1,2,3 etc

CALL apoc.export.cypher.all(null)
YIELD cypherStatements 
RETURN cypherStatements

CREATE (:DependentWord{text:'哪里', alt_text:'哪裡', english:'where', pinyin:'nǎlǐ', require_all: TRUE, tones:'na3li3', word_id: 156})

MATCH(w:StudyWord),(dw:DependentWord {word_id: 156})
WHERE w.text = '哪儿' OR w.text = '里' 
CREATE(dw)-[:DERIVED_FROM]->(w)
RETURN w,dw

MATCH(i:TimeInterval)<-[r:AUTHORING_INTERVAL]-(a:Author)
DELETE r
RETURN i,a

MATCH(i:TimeInterval {interval_order: 1}),(a:Author)
MERGE(a)-[:AUTHORING_INTERVAL]->(i) 
RETURN i,a

MATCH (i2:Interval)-[:NEXT_TIME]->(:Interval)<-[r:AUTHORING_INTERVAL]-(:Author)
CALL apoc.refactor.to(r, i2) YIELD input, output
RETURN 1


CALL apoc.export.cypher.all(null)
YIELD cypherStatements

import React , { Component } from 'react';
//import LongButton from './shared/LongButton.js'
import PropTypes from 'prop-types';
import constants from './shared/constants.js'
import Select from "react-select";

                   UNION
                      MATCH (dw:DependentWord)-[:DERIVED_FROM]->(sw:StudyWord),(this)
                      WITH dw, collect(sw) AS dependencies,this
                      WHERE dw.require_all AND ALL(sw in dependencies WHERE (this)<-[:SHOWN_IN]-(:Sentence)-[:TEACHES | CONTAINS]->(sw))
                      OR dw.require_all = FALSE AND ANY(sw in dependencies WHERE (this)<-[:SHOWN_IN]-(:Sentence)-[:TEACHES | CONTAINS]->(sw))
                      OPTIONAL MATCH (dw)<-[:TEACHES]-(s:Sentence)-[:AT_INTERVAL]->(i)<-[:AUTHORING_INTERVAL]-(:Author)
                      WITH dw,s
                      WHERE s is NULL
                      RETURN dw AS word

const customStyles = {

	control: (provided, state) => ({
		...provided,
		"background-color": state.selectProps.show_answer  ? "default" : state.selectProps.menuColor,
		"border-color": state.selectProps.show_answer ? state.selectProps.borderColor: "default",
		"border-width": state.selectProps.show_answer ? "5px" : "default",

	}),
	option: (styles, { data}) => {
		return {
		  ...styles,
		  backgroundColor: data.color,
		  color: "black",
		  fontWeight: "bold",
		  height: "40px",
		  fontSize: "45px"
		}
	},
	valueContainer: (provided) => ({
		...provided,
		paddingRight: "25px"
	 }),
	container: (provided,state) => ({
		...provided,
		width: "fit-content",
		float: state.selectProps.characterCount > 1 || state.selectProps.hasDescription ? "left" : "none",
		marginLeft: state.selectProps.characterCount > 1 ? "40px" : "80px",
	}),
	singleValue: (provided) => ({
	...provided,
	"fontWeight": "bold"
	}),

}


class Chinese extends Component {

	state = {
		dd_array: [],
		word_to_study: {},
		show_answer: false
	}

	componentDidUpdate(prevProps, prevState) {
		if(prevProps.show_answer === true && this.props.show_answer === false){
			this.replaceWords()
		} else if(this.state.show_answer !== this.props.show_answer){
			this.setState({show_answer: this.props.show_answer})
		}
	}

	componentDidMount() {
		this.replaceWords()
	}

	handleChange = (selectedOption) => {
		var updatedWords = this.state.dd_array 
		console.log("selected option:", selectedOption)
		updatedWords[selectedOption.word_index].word_attributes[selectedOption.attribute_index].color = selectedOption.color
		updatedWords[selectedOption.word_index].word_attributes[selectedOption.attribute_index].selected_tone = selectedOption.value
		updatedWords[selectedOption.word_index].word_attributes[selectedOption.attribute_index].is_correct = (selectedOption.value === updatedWords[selectedOption.word_index].word_attributes[selectedOption.attribute_index].correct_tone)
		console.log("correct tone:",updatedWords[selectedOption.word_index].word_attributes[selectedOption.attribute_index].correct_tone)
		console.log("selected tone:",selectedOption.selected_tone)
		console.log("is_correct:",updatedWords[selectedOption.word_index].word_attributes[selectedOption.attribute_index].is_correct)
		this.setState({dd_array: updatedWords})
   }

	replaceWords () {
		var newWords = []
		this.props.all_words.forEach(function(word,word_index){
			newWords.push({word_text: word.word_text, pinyin: word.alt_word_text2, english: word.english, word_attributes: []})
			word.word_attributes.forEach(function(attr,attr_index){
				newWords[word_index].word_attributes.push({
					label: attr.word_attribute_alt_text, value: 0, interval_id: attr.interval_id, color: 'default', selected_tone: 0,
				 	correct_tone: parseInt(attr.word_attribute_text.slice(-1)), word_attribute_id: attr.word_attribute_id, is_correct: false, word_attr_ready: attr.word_attr_ready})
			})

		})
		this.setState({ dd_array: newWords, word_to_study: Object.assign({},this.props.word_to_study), all_words: [...this.props.all_words], show_answer: this.props.show_answer})
	}


	renderDropDowns = (word, word_index) => {
		let _this = this
		let button_array = []
		let english
		if (_this.state.dd_array.length) {
				english = word.english
 	    		_this.state.dd_array[word_index].word_attributes.forEach(function(dd,dd_index){
		 	    	button_array.push
		 	    	(
		 	    			<div>
		 	    			<Select
		 	    				value={dd}
		 	    				styles={customStyles}
		 	    				menuColor={dd.color}
		 	    				borderColor={dd.is_correct ? "green" : "red"}
		 	    				show_answer={_this.state.show_answer}
		 	    				hasDescription={english.length}
		 	    				characterCount={word.word_attributes.length}
		 	    				options={constants.TONES.map(tone => Object.assign(Object.assign({},tone), { word_index: word_index, attribute_index: dd_index }))}
		 	    				onChange={_this.handleChange}>
       						</Select>
       						<p style={{"fontSize": "12px"}}>{english}</p>
       						</div>
       				)
				})

		}

		return button_array
	}

	getAttemptList = () => {
		var attempt_list = []
	    let _this = this
		_this.state.dd_array.forEach(function(word,word_index){
			word.word_attributes.forEach(function(dd,dd_index) {
	  			attempt_list.push([_this.props.userId, dd.word_attribute_id, dd.word_attr_ready ? _this.props.calculateInterval(dd.interval_id, dd.is_correct): dd.interval_id])
  			})
  		})	
      	return attempt_list
    }


	render() {
		console.log(this.state.show_answer)
	    let _this = this
	    return (
	    	<div style={{ "width": "100%"}}>
	    	{_this.props.wordsButton(_this.getAttemptList)}
	    	<p> Pick the correct tones for "{Object.keys(_this.state.word_to_study).length && _this.state.word_to_study.alt_word_text.replace(/[0-9]/g, '')}"</p>
	    	{_this.state.dd_array.map((word,index) => 
	    		<div style={word.word_attributes.length > 1 ? { "marginBottom": "140px", "marginLeft": "35%"} : {"marginBottom": "90px", "marginLeft": "35%"}}>
	    			<div>
		    		{_this.renderDropDowns(word,index)}
		    		</div>
		    		{_this.state.show_answer ? `Correct answer: ${word.pinyin}`: null}
	    		</div>
	    	
	    	)}
	    	</div>
	    )


	}


}

Chinese.propTypes = {
	word_to_study: PropTypes.object.isRequired,
	all_words: PropTypes.array.isRequired,
	handleWordClick: PropTypes.func.isRequired,
	show_answer: PropTypes.bool.isRequired,
	wordsButton: PropTypes.func.isRequired,
	userId: PropTypes.number.isRequired,
	calculateInterval: PropTypes.func.isRequired
}

export default Chinese;



  /*updateStoreAfterAddSentence(store, refetch){
    const data = store.readQuery({ query: GET_LEVEL_WORDS })
    //for each word used increment times_used, then sort addable_words

    if(!this.replaceMode){
      //const sentence_words = this.state.SentenceElements.filter(element => element.hasOwnProperty('word_id')).map(word => word.text)
      //const contained words = sentence_words.filter(word => word!==this.state.wordToTeach)


      //if it is not the last word in the interval
      if(data.Author[0].level.teachable_words.length > 1){
        if(data.Author[0].interval.interval_order === 1){
              data.Author[0].level.addable_words.push(this.state.wordToTeach)
        }
        data.Author[0].level.teachable_words = data.Author[0].level.teachable_words.filter((word=> word.word_id !== this.state.wordToTeach.word_id))
        //used for checking if a sentence is unique
        data.Author[0].interval.sentences.push({__typename: "Sentence", clean_text: sentence_words.join('')})
        store.writeQuery({ query: GET_LEVEL_WORDS, data })
      } 
      else {
        refetch()
      }
    }
    else{
      refetch()
    }

  }*/



 VALIDATION

MATCH (s:Sentence)-[:CONTAINS]->(w:Word)
WHERE NOT EXISTS((s)-[:DEPENDS_ON]->(:Sentence)-[:TEACHES]->(w))
RETURN s,w

MATCH(s)-[:AT_INTERVAL]->(i)
WHERE i.interval_order<3 AND NOT EXISTS((s)<-[:DEPENDS_ON]-())
RETURN s